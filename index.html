<!DOCTYPE html>
<html>
    <head>
        <link rel="stylesheet" href="static/index.css">
        <script src="https://cdn.jsdelivr.net/npm/brython@3.8.10/brython.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/brython@3.8.10/brython_stdlib.js"></script>
    </head>
    <body onload="brython()">

        <div id="board">
            <div id="squares-div"></div>
            <div id="pieces-div"></div>
        </div>
        <script type="text/python">
"""
This is The Bad Chess Engine.
It gives you the tools to make a usable chess game.

The logic is contained in the 'Chess' class.
From this class you'll use:
- get_piece_moves() to get some piece's moves
- get_king_status() to determine tie, check or checkmate,
    avaliable moves to protect against that check and
    pinned pieces (and their possible moves).
- move_piece() to change the position between two pieces.
- replace_piece() to turn a piece into another or add a new one.

Additionally, there are variables such as has_king_moved and has_rook_moved,
    used to determine whether a castle (move) is possible.
"""


from enum import Enum, auto


class PieceTeam(Enum):
    WHITE = auto()
    BLACK = auto()


class PieceName(Enum):
    KING   = auto()
    QUEEN  = auto()
    BISHOP = auto()
    KNIGHT = auto()
    ROOK   = auto()
    PAWN   = auto()


EMPTY_SQUARE = (None, None)


class Chess:
    """
    Wrapper for the main logic of the chess engine.
    """

    def __init__(self):
        self.in_check = None
        self.checkmate = None
        self.tie = False
        self.moves_to_defend_check = []
        self.pinned_pieces = {}

                            #  White  Black
        self.has_king_moved = [False, False]
        self.has_rook_moved = [[False, False], [False, False]]
                            #  WL      WR      BL      BR
        self.set()


    def get_piece_moves(self, x: int, y: int, show_protected=False, consider_pins=False):
        """
        Returns every legal move for a specific piece, given a position.
        - show_protected: add those squares protected by the selected piece.
        - consider_pins: takes pinned pieces into consideration.
        """

        PIECE_MOVES = {
            PieceName.KING   : self.k,
            PieceName.QUEEN  : self.q,
            PieceName.BISHOP : self.b,
            PieceName.KNIGHT : self.n,
            PieceName.ROOK   : self.r,
            PieceName.PAWN   : self.p,
        }

        piece_name, piece_team = self.get_piece(x, y)

        if piece_name == None:
            return []

        piece_moves = PIECE_MOVES[piece_name](x, y, show_protected)

        if consider_pins:
            if (x, y) in self.pinned_pieces:
                possible_moves = self.pinned_pieces[(x, y)]
                piece_moves = [move for move in piece_moves if move in possible_moves]

        if self.in_check == piece_team and piece_name != PieceName.KING:
            piece_moves = [move for move in piece_moves if move in self.moves_to_defend_check]

        return piece_moves


    # Pawn moves
    def p(self, x: int, y: int, show_protected=False):
        p = self.get_piece(x, y)
        if p:
            _, piece_team = p

            forward = 1 if piece_team == PieceTeam.BLACK else -1
            has_moved = y != (1 if piece_team == PieceTeam.BLACK else 6)
            output = []

            # Forward one square
            aux = (x, y + forward)
            if self.get_piece(aux[0], aux[1]) == EMPTY_SQUARE:
                output.append(aux)

                # Forward two sqwares
                aux = (x, y + 2 * forward)
                if (not has_moved) and self.get_piece(aux[0], aux[1]) == EMPTY_SQUARE:
                    output.append(aux)

            output += self.p_attack(x, y, piece_team, show_protected)
            return output

        # Invalid pos (OOB)
        return False


    def p_attack(self, x: int, y: int, team: PieceTeam, show_protected=False):
        output = []
        forward = 1 if team == PieceTeam.BLACK else -1

        for aux in [(x + 1, y + forward), (x - 1, y + forward)]:
            target = self.get_piece(aux[0], aux[1])
            if target:
                target_name, target_team = target

                if ((target != EMPTY_SQUARE and target_team != team and target_name != PieceName.KING) or
                (target == EMPTY_SQUARE and show_protected)):
                    output.append(aux)

                # Add protected pieces to the list
                if show_protected and target_team == team and target_name != PieceName.KING:
                    output.append(aux)

        return output


    # Rook moves
    def r(self, x: int, y: int, show_protected=False):
        p = self.get_piece(x, y)
        if p:
            _, piece_team = p
            output = []

            for tempname in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                i = 1
                tx = x + tempname[0]
                ty = y + tempname[1]
                target = self.get_piece(tx, ty)

                while target and target[1] != piece_team:
                    i += 1

                    if target == EMPTY_SQUARE:
                        output.append((tx, ty))
                    else:
                        if target[0] != PieceName.KING:
                            output.append((tx, ty))
                        if not show_protected or target[0] != PieceName.KING:
                            break

                    tx = x + tempname[0] * i
                    ty = y + tempname[1] * i
                    target = self.get_piece(tx, ty)
                else:
                    if target:
                        target_name, _ = target

                        # Protected pieces
                        if show_protected and target_name != PieceName.KING:
                            output.append((tx, ty))

            return output
        return None


    # Knight moves
    def n(self, x: int, y: int, show_protected=False):
        p = self.get_piece(x, y)
        if p:
            _, piece_team = p
            output = []

            for tempname in [(1, 2), (-1, 2), (1, -2), (-1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1)]:
                tx = x + tempname[0]
                ty = y + tempname[1]
                target = self.get_piece(tx, ty)

                if target is None:
                    output.append((tx, ty))
                else:
                    if target:
                        target_name, target_team = target

                        if target_team != piece_team and target_name != PieceName.KING:
                            output.append((tx, ty))

                        # Protected pieces
                        if show_protected and target_team == piece_team and target_name != PieceName.KING:
                            output.append((tx, ty))

            return output
        return None


    # Bishop moves
    def b(self, x: int, y: int, show_protected=False):
        p = self.get_piece(x, y)
        if p:
            _, piece_team = p
            output = []

            for tempname in [(1, 1), (1, -1), (-1, 1), (-1, -1)]:
                i = 1
                tx = x + tempname[0]
                ty = y + tempname[1]
                target = self.get_piece(tx, ty)

                while target and target[1] != piece_team:
                    i += 1

                    if target == EMPTY_SQUARE:
                        output.append((tx, ty))
                    else:
                        if target[0] != PieceName.KING:
                            output.append((tx, ty))
                        if not show_protected or target[0] != PieceName.KING:
                            break

                    tx = x + tempname[0] * i
                    ty = y + tempname[1] * i
                    target = self.get_piece(tx, ty)
                else:
                    if target:
                        target_name, _ = target

                        # Protected pieces
                        if show_protected and target_name != PieceName.KING:
                            output.append((tx, ty))

            return output
        return None


    # Queen moves
    def q(self, x: int, y: int, show_protected=False):
        diagonal = self.b(x, y, show_protected)
        straight = self.r(x, y, show_protected)

        if diagonal == EMPTY_SQUARE or straight == EMPTY_SQUARE:
            return EMPTY_SQUARE
        else:
            return straight + diagonal


    # King moves
    def k(self, x: int, y: int, show_protected=False):
        p = self.get_piece(x, y)
        if p:
            _, piece_team = p
            king_moves = []

            for tempname in [(1, 0), (1, 1), (0, 1), (-1, 1), (-1, 0), (-1, -1), (0, -1), (1, -1)]:
                tx = x + tempname[0]
                ty = y + tempname[1]
                target = self.get_piece(tx, ty)

                if target:
                    _, target_team = target

                    if target == EMPTY_SQUARE:
                        king_moves.append((tx, ty))

                    elif target_team != piece_team:
                        king_moves.append((tx, ty))

                    # Protected pieces
                    elif show_protected and target_team == piece_team:
                        king_moves.append((tx, ty))

            if not show_protected:
                bad_squares = self.get_every_square_the_king_cant_be_in(piece_team)
                king_moves = [move for move in king_moves if move not in bad_squares]

                p = piece_team.value - 1
                king_y = 0 if piece_team == PieceTeam.BLACK else 7

                # Castling!
                if not self.has_king_moved[p] and self.in_check != piece_team:
                    r = self.get_piece(0, king_y)
                    if not self.has_rook_moved[p][0] and r[0] == PieceName.ROOK and r[1] == piece_team:
                        for x in range(3, 0, -1):
                            if (x, king_y) in bad_squares or self.get_piece(x, king_y) != EMPTY_SQUARE:
                                break
                        else:
                            king_moves.append((0, king_y))

                    r = self.get_piece(7, king_y)
                    if not self.has_rook_moved[p][1] and r[0] == PieceName.ROOK and r[1] == piece_team:
                        for x in range(5, 7):
                            if (x, king_y) in bad_squares or self.get_piece(x, king_y) != EMPTY_SQUARE:
                                break
                        else:
                            king_moves.append((7, king_y))

            return king_moves

        return None


    def find_king_pos(self, team: PieceTeam):
        """
        Where's the king?
        """
        king_to_look_for = 'k' if team == PieceTeam.BLACK else 'K'

        for i, p in enumerate(self.board):
            for j in range(8):
                if p[j] == king_to_look_for:
                    return (j, i)

        raise ValueError('How tf is there no king on the board?')


    def get_king_status(self, team: PieceTeam):
        """
        Sets the in_check flag, pinned_pieces and a list of moves
        to defend the check.
        """

        # Clear values of previous position.
        self.in_check = None
        self.moves_to_defend_check = []
        self.pinned_pieces = {}

        kx, ky = self.find_king_pos(team)
        forward = 1 if team == PieceTeam.BLACK else -1

        # Straight line.
        for tempname in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            path = []
            remembered_piece = None

            i = 1
            tx = kx + tempname[0]
            ty = ky + tempname[1]
            target = self.get_piece(tx, ty)

            while target:
                target_name, target_team = target

                if target == EMPTY_SQUARE:
                    path.append((tx, ty))

                elif target_team == team:
                    if remembered_piece: break
                    else: remembered_piece = (tx, ty)

                else: # target_team != team
                    if target_name in (PieceName.ROOK, PieceName.QUEEN):
                        path.append((tx, ty))

                        # Pin
                        if remembered_piece:
                            rx, ry = remembered_piece
                            self.pinned_pieces[remembered_piece] = [
                                move for move in self.get_piece_moves(rx, ry)
                                if move in path
                            ]
                            break

                        # Check
                        else:
                            self.moves_to_defend_check += path
                            self.in_check = team
                            break
                    else:
                        break

                i += 1
                tx = kx + tempname[0] * i
                ty = ky + tempname[1] * i
                target = self.get_piece(tx, ty)

        # Diagonal line.
        for tempname in [(1, 1), (1, -1), (-1, 1), (-1, -1)]:
            path = []
            remembered_piece = None

            i = 1
            tx = kx + tempname[0]
            ty = ky + tempname[1]
            target = self.get_piece(tx, ty)

            while target:

                target_name, target_team = target

                if target == EMPTY_SQUARE:
                    path.append((tx, ty))

                elif target_team == team:
                    if remembered_piece: break
                    else: remembered_piece = (tx, ty)

                else: # target_team != team
                    if target_name in (PieceName.BISHOP, PieceName.QUEEN):
                        path.append((tx, ty))

                        # Pin
                        if remembered_piece:
                            rx, ry = remembered_piece
                            self.pinned_pieces[remembered_piece] = [
                                move for move in self.get_piece_moves(rx, ry)
                                if move in path
                            ]
                            break

                        # Check
                        else:
                            self.moves_to_defend_check += path
                            self.in_check = team
                            break
                    else:
                        break
                i += 1
                tx = kx + tempname[0] * i
                ty = ky + tempname[1] * i
                target = self.get_piece(tx, ty)

        # Knights
        for tempname in [(1, 2), (-1, 2), (1, -2), (-1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1)]:
            tx = kx + tempname[0]
            ty = ky + tempname[1]
            target = self.get_piece(tx, ty)

            if target:
                target_name, target_team = target

                if target_name == PieceName.KNIGHT and target_team != team:
                    self.in_check = team
                    self.moves_to_defend_check = [(tx, ty)]

        # Pawns
        for i in (1, -1):
            target = self.get_piece(kx + i, ky + forward)
            if not target or target == EMPTY_SQUARE: continue

            target_name, target_team = target

            if target_name == PieceName.PAWN and target_team != team:
                self.in_check = team
                self.moves_to_defend_check = [(kx + i, ky + forward)]

        if not self.can_move(team):
            if self.in_check == team:
                self.checkmate = team
            else:
                self.tie = True

        else: # Check if there're only kings
            for line in C.board:
                line = line.replace('.', '')
                if line != '' and line != 'k' and line != 'K':
                    return

            self.tie = True


    def get_every_square_the_king_cant_be_in(self, team: PieceTeam):
        squares = []
        oposing_team = PieceTeam.BLACK if team == PieceTeam.WHITE else PieceTeam.WHITE

        PIECE_MOVES = {
            PieceName.KING   : self.k,
            PieceName.QUEEN  : self.q,
            PieceName.BISHOP : self.b,
            PieceName.KNIGHT : self.n,
            PieceName.ROOK   : self.r,
        }

        for i in range(8):
            for j in range(8):
                piece = self.get_piece(j, i)

                if piece == EMPTY_SQUARE or piece[1] == team: continue

                if piece[0] == PieceName.PAWN:
                    squares += self.p_attack(j, i, oposing_team, show_protected=True)
                else:
                    squares += PIECE_MOVES[piece[0]](j, i, show_protected=True)

        return squares


    def can_move(self, team: PieceTeam):
        """
        Returns a boolean value: whether a team can move or not.
        """

        for y in range(8):
            for x in range(8):
                piece_name, piece_team = self.get_piece(x, y)

                if piece_name != None and piece_team == team:
                    if self.get_piece_moves(x, y, consider_pins=True):
                        return True

        return False


    def move_piece(self, ox: int, oy: int, dx: int, dy: int, castle: bool):
        """
        Replaces characters on the board without performing any checks.
        """

        origin_line = list(self.board[oy])
        destiny_line = list(self.board[dy])

        if castle: # origin = king, destiny = rook
            castle_dir = 1
            if dx < ox: castle_dir = -1

            king_x = ox + (2 * castle_dir)

            destiny_line[ox] = '.'
            destiny_line[dx] = '.'
            destiny_line[king_x] = self.board[oy][ox]
            destiny_line[king_x + (1 * castle_dir * -1)] = self.board[dy][dx]
        else:
            if oy == dy:
                destiny_line[ox] = '.'

            origin_line[ox] = '.'
            destiny_line[dx] = self.board[oy][ox]

        new_board = list(self.board)
        new_board[oy] = ''.join(origin_line)
        new_board[dy] = ''.join(destiny_line)

        self.board = tuple(new_board)


    def set(self):
        """
        Resets the board to it's default layout and the cursor to its default
        position.
        """

        self.in_check = None
        self.checkmate = None
        self.tie = False
        self.moves_to_defend_check = []
        self.pinned_pieces = {}
        self.has_king_moved = [False, False]
        self.has_rook_moved = [[False, False], [False, False]]

        self.board = (
            'rnbqkbnr',
            'pppppppp',
            '........',
            '........',
            '........',
            '........',
            'PPPPPPPP',
            'RNBQKBNR',
        )


    def get_piece(self, x: int, y: int):
        """
        Returns the piece in the given x, y coordinate.
        """

        piece_info = {
            'p' : (PieceName.PAWN,   PieceTeam.BLACK),
            'P' : (PieceName.PAWN,   PieceTeam.WHITE),
            'r' : (PieceName.ROOK,   PieceTeam.BLACK),
            'R' : (PieceName.ROOK,   PieceTeam.WHITE),
            'n' : (PieceName.KNIGHT, PieceTeam.BLACK),
            'N' : (PieceName.KNIGHT, PieceTeam.WHITE),
            'b' : (PieceName.BISHOP, PieceTeam.BLACK),
            'B' : (PieceName.BISHOP, PieceTeam.WHITE),
            'q' : (PieceName.QUEEN,  PieceTeam.BLACK),
            'Q' : (PieceName.QUEEN,  PieceTeam.WHITE),
            'k' : (PieceName.KING,   PieceTeam.BLACK),
            'K' : (PieceName.KING,   PieceTeam.WHITE),
            '.' : EMPTY_SQUARE,
        }

        if 0 <= x <= 7 and 0 <= y <= 7:
            return piece_info[self.board[y][x]]
        else:
            return False

    def replace_piece(self, x: int, y: int, name: PieceName, team: PieceTeam):
        piece_dict = {
            PieceName.KING   : 'k',
            PieceName.QUEEN  : 'q',
            PieceName.ROOK   : 'r',
            PieceName.BISHOP : 'b',
            PieceName.KNIGHT : 'n',
            PieceName.PAWN   : 'p',
        }

        new_board = list(self.board)
        line = list(new_board[y])
        line[x] = piece_dict[name]

        if team == PieceTeam.WHITE:
            line[x] = line[x].upper()

        new_board[y] = ''.join(line)
        self.board = tuple(new_board)
####################################################################

from browser import document, window, timer
from browser.html import TABLE, TR, TH, TD, DIV, IMG

C = Chess()
selected_square = -1
possible_moves = []

MAX_STEPS = 20

turn = PieceTeam.WHITE
can_move = True

def is_white(x: int, y: int):
    return (x % 2 == 0 and y % 2 == 0) or (x % 2 != 0 and y % 2 != 0)


def click(square: str):
    global selected_square, possible_moves, turn, can_move

    if not can_move:
        return None

    square = int(square)

    if selected_square == -1:
        selected_square = square
        document[str(selected_square)].style.backgroundColor = '#49f540' if is_white(square % 8, square // 8) else '#257a21'

        x, y = selected_square % 8, selected_square // 8
        piece = C.get_piece(x, y)

        if p != EMPTY_SQUARE and piece[1] == turn:
            moves = C.get_piece_moves(x, y, consider_pins=True)
            create_moving_piece(selected_square)

            for x, y in moves:
                _id = str((y * 8) + x)
                possible_moves.append(_id)
                document[_id].style.backgroundColor = '#49f540' if is_white(x, y) else '#257a21'
        else:
            document[str(selected_square)].style.backgroundColor = 'white' if is_white(selected_square % 8, selected_square // 8) else 'black'
            selected_square = -1
            return None

    elif selected_square != -1:
        document[str(selected_square)].style.backgroundColor = '#49f540' if is_white(selected_square % 8, selected_square // 8) else '#257a21'

        if selected_square == square or str(square) not in possible_moves:
            document[str(selected_square)].style.backgroundColor = 'white' if is_white(selected_square % 8, selected_square // 8) else 'black'
            selected_square = -1

            for s in possible_moves:
                s = int(s)
                x, y = s % 8, s // 8
                document[str(s)].style.backgroundColor = 'white' if is_white(x, y) else 'black'

            possible_moves = []
            if 'moving-piece' in document:
                del document['moving-piece']

        elif str(square) in possible_moves:
            ox, oy = int(selected_square) % 8, int(selected_square) // 8
            dx, dy = square % 8, square // 8
            origin_name, origin_team = C.get_piece(ox, oy)
            destiny_name, destiny_team = C.get_piece(dx, dy)

            castle = False
            if origin_name == PieceName.KING and destiny_name == PieceName.ROOK and origin_team == destiny_team:
                castle = True

            castle_y = 0 if origin_team == PieceTeam.BLACK else 7
            pawn_promotion_y = 0 if origin_team == PieceTeam.WHITE else 7
            promotion = dy == pawn_promotion_y and origin_name == PieceName.PAWN

            if origin_name == PieceName.ROOK:
                side = 0 if ox == 0 and oy == castle_y else 1
                C.has_rook_moved[origin_team.value - 1][side] = True

            move_piece(selected_square, str(square), castle, origin_team.name, promotion)

            for s in possible_moves:
                s = int(s)
                x, y = s % 8, s // 8
                document[str(s)].style.backgroundColor = 'white' if is_white(x, y) else 'black'

            possible_moves = []
            document[str(selected_square)].style.backgroundColor = 'white' if is_white(selected_square % 8, selected_square // 8) else 'black'
            selected_square = -1

            turn = PieceTeam.BLACK if turn == PieceTeam.WHITE else PieceTeam.WHITE
            C.get_king_status(turn)


def get_square(square_id):
    table = list(document['squares'])
    i_square_id = int(square_id)

    x, y = i_square_id % 8, i_square_id // 8
    return list(table[y])[x]


def put_piece_in_square(square_id, name_str, team_str):
    if name_str == 'None':
        get_square(square_id).innerHTML = ''
    else:
        get_square(square_id).innerHTML = f'<img src="static/pieces/{team_str}_{name_str}.png">'


def render_board():
    for y in range(8):
        for x in range(8):
            name, team = C.get_piece(x, y)
            if name != None:
                put_piece_in_square(
                    str(y * 8 + x),
                    str(name.name),
                    str(team.name),
                )


def create_moving_piece(origin_id):
    origin = get_square(origin_id)
    piece_div = DIV(
        id='moving-piece',
        style={
            'left'    : f'{origin.x + 3}px',
            'top'     : f'{origin.y + 1}px',
            'z-index' : '-1',
        }
    )
    piece_div.innerHTML = origin.innerHTML
    document <= piece_div


def move_piece(origin_id, destiny_id, is_castle, team=None, promotion):
    origin = get_square(origin_id)
    destiny = get_square(destiny_id)
    ox = int(origin_id) % 8
    oy = int(origin_id) // 8
    dx = int(destiny_id) % 8
    dy = int(destiny_id) // 8

    put_piece_in_square(origin_id, 'None', 0)

    moving_piece = document['moving-piece']
    moving_piece.style.zIndex = '10'
    moving_piece_img = document['moving-piece'].innerHTML

    def animated_move(timestamp, x_dir, y_dir, step, max_step, castle_dir):
        moving_piece.left += int(x_dir)
        moving_piece.top += int(y_dir)

        if step < max_step:
            timer.request_animation_frame(
                lambda timestamp:
                animated_move(timestamp, x_dir, y_dir, step + 1, max_step, castle_dir)
            )
        else:
            offset = int(moving_piece.clientWidth * 0.9)
            del document['moving-piece']

            if castle_dir != 0:
                destiny.innerHTML = ''

                put_piece_in_square(str(int(origin_id + 2 * castle_dir)), 'king', team)
                put_piece_in_square(str(int(origin_id) + castle_dir), 'rook', team)

                t_value = 0 if team == 'WHITE' else 1

                C.has_king_moved[t_value] = True
                C.has_rook_moved[t_value][int(not dx == 0)] = True
            else:
                global can_move
                destiny.innerHTML = moving_piece_img

                if promotion == True: # Display menu for options
                    can_move = False
                    selection_box = DIV(id='piece-select')

                    for name in (PieceName.QUEEN, PieceName.ROOK, PieceName.BISHOP, PieceName.KNIGHT):
                        container = DIV(
                            Class="container",
                            onclick=f'promote_pawn({dx}, {dy}, "{name}", "{team}");'
                        )
                        container <= IMG(src=f'static/pieces/{team}_{name.name}.png')

                        selection_box <= container

                    selection_box.style.left = str(moving_piece.left + offset) + 'px'
                    selection_box.style.top = str(moving_piece.top) + 'px'
                    document <= selection_box

    castle_dir = 0
    if is_castle:
        if dx > ox: castle_dir = 1
        elif ox > dx: castle_dir = -1
        x_dir = (get_square(int(origin_id) + (2 * castle_dir)).x - origin.x) / MAX_STEPS
        y_dir = 0
    else:
        x_dir = (destiny.x - origin.x) / MAX_STEPS
        y_dir = (destiny.y - origin.y) / MAX_STEPS

    timer.request_animation_frame(
        lambda timestamp: animated_move(
            timestamp, x_dir, y_dir, 0, MAX_STEPS, castle_dir
        )
    )

    C.move_piece(ox, oy, dx, dy, is_castle)


def promote_pawn(x: int, y: int, name: PieceName, team_str: str):
    global can_move

    C.replace_piece(x, y, eval(name), eval('PieceTeam.' + team_str))
    put_piece_in_square(str(y * 8 + x), eval(name).name, team_str)

    del document['piece-select']
    can_move = True
    C.get_king_status(PieceTeam.BLACK if team_str == 'WHITE' else PieceTeam.WHITE)


# This is done to have this function usable in js
window.click = click
window.promote_pawn = promote_pawn

####################################################################

# Create table
s = TABLE(id='squares')
p = TABLE(id='pieces')

colors = [(0, 0, 0), (255, 255, 255)]

for row in range(8):
    sr = TR()
    pr = TR()
    color = row % 2 == 0

    for column in range(8):
        _id = str(row*8 + column)

        sr <= TD(
            id=_id,
            style={'background-color' : f'rgb{colors[int(color)]}'}
        )
        pr <= TD(
            id=_id,
            onclick=f"click('{_id}');"
        )
        color = not color

    s <= sr
    p <= pr

document['squares-div'] <= s
document['pieces-div'] <= p

render_board()

        </script>
    </body>
</html>
